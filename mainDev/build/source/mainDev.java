/* autogenerated by Processing revision 1276 on 2021-09-26 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.Collections;
import java.util.Random;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class mainDev extends PApplet {




final int ratio = 13;
final float largeurTerrain = 105;
final float hauteurTerrain = 68;

final int BGCOLOR = color(28, 32, 36);
final int PINGCOLOR = color(255,0,0);

boolean INPUTMODE;


Field field;

boolean resetCheck = true;
boolean drawGUICheck = false;

int team1NextJerseyNumber;
int team2NextJerseyNumber;
ArrayList<Integer> team1JerseyNumbers;
ArrayList<Integer> team2JerseyNumbers;
ArrayList<Integer> team1FreeJerseyNumbers;
ArrayList<Integer> team2FreeJerseyNumbers;

ArrayList<Player> team1;
ArrayList<Player> team2;

ArrayList<Arrow> arrows;

Ball ball;




 public void setup() {
	frameRate(60);

	/* size commented out by preprocessor */;
	background(255);
	fill(0);

	field = new Field(11);

	computeCoordinates();

	team1 = new ArrayList<Player>();
	team2 = new ArrayList<Player>();

	team1JerseyNumbers = new ArrayList<Integer>();
	team2JerseyNumbers = new ArrayList<Integer>();
	team1FreeJerseyNumbers = new ArrayList<Integer>();
	team2FreeJerseyNumbers = new ArrayList<Integer>();

	arrows = new ArrayList<Arrow>();

	ball = new Ball(255, width/2, height/2);

	INPUTMODE = false;

}



 public void draw() {

	reset();
	field.drawField();

	drawPlayers();
	ball.drawBall();
	drawArrows();


	if(INPUTMODE) {
		runInputMode();
	} else {
		runEventManager();
	}




}



 public void reset() {
	background(BGCOLOR); // Background de reset
}

 public void drawPlayers() {
	if(!team1.isEmpty()) {
		for(int i = 0; i < team1.size(); i++) {
			team1.get(i).drawPlayer();
		}
	}

	if(!team2.isEmpty()) {
		for(int i = 0; i < team2.size(); i++) {
			team2.get(i).drawPlayer();
		}
	}
}

 public void drawArrows() {
	if(!arrows.isEmpty()) {
		for(int i = 0; i < arrows.size(); i++) {
			arrows.get(i).drawArrow();
		}
	}
}
class Arrow
{

	private final float ratio = 35;
	final private float tokenRadius = 1.5f*this.ratio;

	private float x1,y1,x2,y2;

	private int col;


	Arrow(float x, float y, float xx, float yy) {
		this.x1 = x;
		this.y1 = y;
		this.x2 = xx;
		this.y2 = yy;
		this.col = color(214, 200, 45);
	}


	 public void drawArrow(){
		stroke(this.col);
		strokeWeight(13);
		line(this.x1, this.y1, this.x2, this.y2);
		pushMatrix();
			translate(this.x2, this.y2);
			float a = atan2(this.x1-this.x2, this.y2-this.y1);
			rotate(a);
			line(0, 0, -20, -20);
			line(0, 0, 20, -20);
		popMatrix();
	}

	 public boolean overArrow(float x, float y) {
		if ( x >= this.x1 && x <= this.x2 && y >= this.y1 && y <= this.y2 )   { return true; } // Flèche vers bas droite
		if ( x >= this.x1 && x <= this.x2 && y <= this.y1 && y >= this.y2 )   { return true; } // Flèche vers haut droite
		if ( x <= this.x1 && x >= this.x2 && y >= this.y1 && y <= this.y2 )   { return true; } // Flèche vers bas gauche
		if ( x <= this.x1 && x >= this.x2 && y <= this.y1 && y >= this.y2 )   { return true; } // Flèche vers haut gauche
		return false;
	}



	// GETTERS SETTERS
	public float getX1() {
		return this.x1;
	}

	public float getY1() {
		return this.y1;
	}

	public void setX1(float xx) {
		this.x1 = xx;
	}

	public void setY1(float yy) {
		this.y1 = yy;
	}

	public float getX2() {
		return this.x2;
	}

	public float getY2() {
		return this.y2;
	}

	public void setX2(float xx) {
		this.x2 = xx;
	}

	public void setY2(float yy) {
		this.y2 = yy;
	}


	public int getColor() {
		return this.col;
	}

	public void setColor(int c) {
		this.col = c;
	}

}
class Ball 
{
  
  final private float tokenRadius = 1.5f*ratio;
  
  private float x,y;

  private int col;
  
 
  Ball(int c, float xx, float yy) {
    this.col = c;
    this.x = xx;
    this.y = yy;
  }
  
  
  public void drawBall() {
    fill(this.col);
    strokeWeight(2);
    stroke(0);
    circle(this.x, this.y,tokenRadius);
  }
  
  
  public boolean isInRange(float xx, float yy, float range) {
    if(this.x > xx - range*ratio && this.x < xx + range*ratio && this.y > yy - range*ratio && this.y < yy + range*ratio) {
      return true;
    }
    return false;
  }
  
   public boolean overBall(float x, float y) {
    if ( (x > this.x - (this.tokenRadius/2)) && (x < this.x + (this.tokenRadius/2)) && (y > this.y - (this.tokenRadius/2))  && (y < this.y + (this.tokenRadius/2)) )   return true;
    return false;
  }
  

  // GETTERS SETTERS
  public float getX() {
    return this.x;
  }
  
  public float getY() {
    return this.y;
  }
  
  public void setX(float xx) {
    this.x = xx;
  }
  
  public void setY(float yy) {
    this.y = yy;
  }
  

  public int getColor() {
    return this.col;
  }
  
  public void setColor(int c) {
    this.col = c;
  }

  
}


float fieldTopLeftCornerX = (width - (ratio*largeurTerrain))/2;
float fieldTopLeftCornerY = (height - (ratio*hauteurTerrain))/2;

float fieldBottomRightCornerX = (ratio*largeurTerrain) + (width-(ratio*largeurTerrain))/2;
float fieldBottomRightCornerY = (ratio*hauteurTerrain) + (height-(ratio*hauteurTerrain))/2;


float leftGoalTopPostX = fieldTopLeftCornerX;
float leftGoalTopPostY = (fieldTopLeftCornerY+fieldBottomRightCornerY)/2 - ((ratio*7.3f)/2);

float leftGoalBottomPostX = fieldTopLeftCornerX;
float leftGoalBottomPostY = (fieldTopLeftCornerY+fieldBottomRightCornerY)/2 + ((ratio*7.3f)/2);


float rightGoalTopPostX = fieldBottomRightCornerX;
float rightGoalTopPostY = (fieldTopLeftCornerY+fieldBottomRightCornerY)/2 - ((ratio*7.3f)/2);

float rightGoalBottomPostX = fieldBottomRightCornerX;
float rightGoalBottomPostY = (fieldTopLeftCornerY+fieldBottomRightCornerY)/2 + ((ratio*7.3f)/2);


 public void computeCoordinates() {
  
  fieldTopLeftCornerX = (width - (ratio*largeurTerrain))/2;
  fieldTopLeftCornerY = (height - (ratio*hauteurTerrain))/2;
  
  fieldBottomRightCornerX = (ratio*largeurTerrain) + (width-(ratio*largeurTerrain))/2;
  fieldBottomRightCornerY = (ratio*hauteurTerrain) + (height-(ratio*hauteurTerrain))/2;
  
  
  leftGoalTopPostX = fieldTopLeftCornerX;
  leftGoalTopPostY = (fieldTopLeftCornerY+fieldBottomRightCornerY)/2 - ((ratio*7.3f)/2);
  
  leftGoalBottomPostX = fieldTopLeftCornerX;
  leftGoalBottomPostY = (fieldTopLeftCornerY+fieldBottomRightCornerY)/2 + ((ratio*7.3f)/2);
  
  
  rightGoalTopPostX = fieldBottomRightCornerX;
  rightGoalTopPostY = (fieldTopLeftCornerY+fieldBottomRightCornerY)/2 - ((ratio*7.3f)/2);
  
  rightGoalBottomPostX = fieldBottomRightCornerX;
  rightGoalBottomPostY = (fieldTopLeftCornerY+fieldBottomRightCornerY)/2 + ((ratio*7.3f)/2);
    
}
// MouseLocked prevents multiple events to be detected at once : once the mouse is locked, no other action will be triggered after the first one, while the same keys are pressed
boolean mouseLocked = false;

int elementInFocusID = -1;

boolean noElementInFocus = true;
boolean elementInFocusIsPlayerTeam1 = false;
boolean elementInFocusIsPlayerTeam2 = false;
boolean ballInFocus = false;

boolean baseArrowLocked = false;
float baseArrowX;
float baseArrowY;
Arrow arrow;

int teamInWhichPlayerIsBeingAdded;

 public void runEventManager() {

	// Souris sur canvas
	if(mouseOverCanvas()) {


		/*
		SUPPRESSION D'ELEMENT
		*/
		if (keyPressed && (key == 'z') && !mouseLocked) {
			if(mousePressed) {
				// Did we click on a player ?
				for(int i = 0; i < team1.size(); i++) {
					if(team1.get(i).overPlayer(mouseX, mouseY)) {
						team1FreeJerseyNumbers.add(team1.get(i).getNumber());
						team1.remove(i);
						break;
					}
				}

				for(int i = 0; i < team2.size(); i++) {
					if(team2.get(i).overPlayer(mouseX, mouseY)) {
						team2FreeJerseyNumbers.add(team2.get(i).getNumber());
						team2.remove(i);
						break;
					}
				}


				// Did we click on an arrow ?
				for(int i = 0; i < arrows.size(); i++) {
					if(arrows.get(i).overArrow(mouseX, mouseY)) {
						arrows.remove(i);
						break;
					}
				}



				mouseLocked = true;
			}
		}


		/*
		CREATION FLECHE
		*/
		else if (keyPressed && (key == 's') && !mouseLocked) {
			if(mousePressed) {
				if(!baseArrowLocked) {
					baseArrowX = mouseX;
					baseArrowY = mouseY;
				}

				baseArrowLocked = true;
				Arrow arrow = new Arrow(baseArrowX, baseArrowY, mouseX, mouseY);
				arrow.drawArrow();

				mouseLocked = true;
			}
		}


		/*
		DEPLACEMENT DE JOUEUR OU DU BALLON
		*/
		else if(mousePressed  && !mouseLocked) { //Si on ne fait que cliquer

			// Did we click on a player ?
			if(noElementInFocus || elementInFocusIsPlayerTeam1) { // Pas d'élément focus ou team1
			if(elementInFocusIsPlayerTeam1) { // si team 1
				team1.get(elementInFocusID).setX(mouseX);
				team1.get(elementInFocusID).setY(mouseY);
			} else { // si rien de focus
				for(int i = 0; i < team1.size(); i++) {
					if(team1.get(i).overPlayer(mouseX, mouseY)) {
						team1.get(i).setX(mouseX);
						team1.get(i).setY(mouseY);
						noElementInFocus = false;
						elementInFocusIsPlayerTeam1 = true;
						elementInFocusID = i;
					}
				}
			}
		} if(noElementInFocus || elementInFocusIsPlayerTeam2) { // Pas d'élément focus ou team2
		if(elementInFocusIsPlayerTeam2) { // si team 2
			team2.get(elementInFocusID).setX(mouseX);
			team2.get(elementInFocusID).setY(mouseY);
		} else {
			for(int i = 0; i < team2.size(); i++) {
				if(team2.get(i).overPlayer(mouseX, mouseY)) {
					team2.get(i).setX(mouseX);
					team2.get(i).setY(mouseY);
					noElementInFocus = false;
					elementInFocusIsPlayerTeam2 = true;
					elementInFocusID = i;
				}
			}
		}
	}


	// Did we click on the ball ?
	if(noElementInFocus || ballInFocus) { // Pas d'élément focus ou ballon
		if(ballInFocus) { // If the ball is already in focus
			ball.setX(mouseX);
			ball.setY(mouseY);
		}
		if(ball.overBall(mouseX, mouseY)) {
			ball.setX(mouseX);
			ball.setY(mouseY);
			noElementInFocus = false;
			ballInFocus = true;
		}
	}



	mouseLocked = true;
	}

	mouseLocked = false;
}


// Souris hors du canvas
else {



}


// Souris sur ou hors canvas

}

 public void mouseReleased() {

	boolean spotTaken = false;

	/*
	CREATION DE JOUEURS
	*/
	if (keyPressed && (key == 'a')) { // Création joueur équipe 1

		for(int i = 0; i < team1.size(); i++) {
			if(team1.get(i).overPlayer(mouseX, mouseY)) { // Si un joueur de la même équipe est déjà à ces coordonnées
				spotTaken = true;
			}
		}

		if(!spotTaken) {
			computeNextJerseyNumber(1);
			team1.add(new Player("Joueur " + team1NextJerseyNumber, 1, team1NextJerseyNumber, mouseX, mouseY));
			team1JerseyNumbers.add(team1NextJerseyNumber);
			mouseLocked = true;
			teamInWhichPlayerIsBeingAdded = 1;
			saved = "Joueur " + team1NextJerseyNumber;
			INPUTMODE = true;
		}
	} else if (keyPressed && (key == 'e') && !mouseLocked) { // Création joueur équipe 2

		for(int i = 0; i < team2.size(); i++) {
			if(team2.get(i).overPlayer(mouseX, mouseY)) { // Si un joueur de la même équipe est déjà à ces coordonnées
				spotTaken = true;
			}
		}

		if(!spotTaken) {
			computeNextJerseyNumber(2);
			team2.add(new Player("Joueur " + team2NextJerseyNumber, 2, team2NextJerseyNumber, mouseX, mouseY));
			team2JerseyNumbers.add(team2NextJerseyNumber);
			mouseLocked = true;
			teamInWhichPlayerIsBeingAdded = 2;
			saved = "Joueur " + team2NextJerseyNumber;
			INPUTMODE = true;
		}
	}


	/*
	DESSIN FLECHE
	*/
	else if (keyPressed && (key == 's') && !mouseLocked) {
		arrows.add(new Arrow(baseArrowX, baseArrowY, mouseX, mouseY));

		mouseLocked = true;
	}




	/*
	RESET DES CONTROLES
	*/
	mouseLocked = false;
	noElementInFocus = true;
	elementInFocusIsPlayerTeam1 = false;
	elementInFocusIsPlayerTeam2 = false;
	ballInFocus = false;

	baseArrowLocked = false;

	/*
	RECALCUL DES ID ET AUTRES NOMBRES
	*/
	elementInFocusID = -1;
}

 public void computeNextJerseyNumber(int team) {

	Collections.sort(team1FreeJerseyNumbers);
	Collections.sort(team2FreeJerseyNumbers);
	Collections.sort(team1JerseyNumbers);
	Collections.sort(team2JerseyNumbers);

	switch (team) {
		case 1:
		if (team1JerseyNumbers.size() == 0) { team1NextJerseyNumber = 1; team1JerseyNumbers.add(team1NextJerseyNumber); }
		else if (team1FreeJerseyNumbers.size() != 0) { team1NextJerseyNumber = team1FreeJerseyNumbers.get(0); team1FreeJerseyNumbers.remove(0);}
		else { team1NextJerseyNumber = team1JerseyNumbers.get(team1JerseyNumbers.size()-1); team1NextJerseyNumber++;}
		break;
		case 2:
		if (team2JerseyNumbers.size() == 0) { team2NextJerseyNumber = 1; team2JerseyNumbers.add(team2NextJerseyNumber); }
		else if (team2FreeJerseyNumbers.size() != 0) { team2NextJerseyNumber = team2FreeJerseyNumbers.get(0); team2FreeJerseyNumbers.remove(0);}
		else { team2NextJerseyNumber = team2JerseyNumbers.get(team2JerseyNumbers.size()-1); team2NextJerseyNumber++;}
		break;
	}

}
class Field {

  private float x1 = (width - (ratio*largeurTerrain))/2;
  private float y1 = (height - (ratio*hauteurTerrain))/2;
  private float x2 = (ratio*largeurTerrain) + (width-(ratio*largeurTerrain))/2;
  private float y2 = (ratio*hauteurTerrain) + (height-(ratio*hauteurTerrain))/2;

  private float fieldLength;
  private float fieldWidth;

  private int brightStripeColor = color(86,110,72);
  private int darkStripeColor = color(93,120,78);

  private int nbStripes;


  Field(int nbS) {
    this.nbStripes = nbS;
  }


  public void drawField() {

		strokeWeight(4);

    this.drawStripes();

    this.drawFieldElements();
  }

  public void drawStripes() {

    float stripesLength = this.y2 - this.y1;
    float stripesWidth = (this.x2 - this.x1)/this.nbStripes;

    rectMode(CORNER);
    noStroke();

    for(int i = 0; i < this.nbStripes; i++) {
      if (i%2 == 0){
        stroke(brightStripeColor);
        fill(brightStripeColor);
      } else {
        stroke(darkStripeColor);
        fill(darkStripeColor);
      }
      rect(this.x1 + (i*stripesWidth), this.y1, stripesWidth, stripesLength);
    }

  }

  public void drawFieldElements() {
    noFill();
    strokeWeight(6);
    stroke(255);

    rect(this.x1, this.y1, ratio*largeurTerrain, ratio*hauteurTerrain); // Play area

    line((this.x1 + this.x2)/2, this.y1, (this.x1 + this.x2)/2, this.y2); // Middle
    //stroke(255,0,0);
    //line(this.x1, (this.y1+this.y2)/2, this.x2, (this.y1+this.y2)/2); // TEMP LINE
    //stroke(255);

    strokeWeight(5);
    circle((this.x1 + this.x2)/2, (this.y1 + this.y2)/2, ratio*(9.15f*2)); // Middle Circle

    rect(this.x1, (this.y1+this.y2)/2 - (ratio*40.3f)/2, ratio*16.5f, ratio*40.3f); // Left penalty area
    rect(this.x2, (this.y1+this.y2)/2 - (ratio*40.3f)/2, -ratio*16.5f, ratio*40.3f); // Right penalty area

    rect(this.x1, (this.y1+this.y2)/2 - ((ratio*18.3f)/2), ratio*5.5f, ratio*18.3f); // Left box area
    rect(this.x2, (this.y1+this.y2)/2 - ((ratio*18.3f)/2), -ratio*5.5f, ratio*18.3f); // Right box area

    rect(this.x1, (this.y1+this.y2)/2 - ((ratio*7.3f)/2), -ratio*2.4f, ratio*7.3f); // Left Goal
    rect(this.x2, (this.y1+this.y2)/2 - ((ratio*7.3f)/2), ratio*2.4f, ratio*7.3f); // Right Goal
  }

  public boolean isInside(float xx, float yy) {
    if (xx >= x1 || xx <= x2 || yy >= y1 || yy <= y2)
      return true;
    return false;
  }

  public boolean isInLeftGoal(float xx, float yy) {
    if (xx < x1 && xx > x1-ratio*2.4f && yy > (this.y1+this.y2)/2 - ((ratio*7.3f)/2) && yy < (this.y1+this.y2)/2 + ((ratio*7.3f)/2))
      return true;
    return false;
  }

  public boolean isInRightGoal(float xx, float yy) {
    if (xx > x2 && xx < x2+ratio*2.4f && yy > (this.y1+this.y2)/2 - ((ratio*7.3f)/2) && yy < (this.y1+this.y2)/2 + ((ratio*7.3f)/2))
      return true;
    return false;
  }




  // GETTERS SETTERS

}

// Variable to store text currently being typed
String typing = "";

// Variable to store saved text when return is hit
String saved = "";

int indent = 25;


 public void runInputMode() {

  fill(255);

  // Display everything
  text("Nom du joueur: \n" + typing,width/2, height/2);
}

 public void keyPressed() {

	if(INPUTMODE) {
		// If the return key is pressed, save the String and clear it
	  if (key == '\n' ) {
			if (typing != "") {
				saved = typing;
			}
	    typing = "";

			if(teamInWhichPlayerIsBeingAdded == 1) {
				team1.get(team1.size() - 1).setName(saved);
			} else if(teamInWhichPlayerIsBeingAdded == 2) {
				team2.get(team2.size() - 1).setName(saved);
			}

			teamInWhichPlayerIsBeingAdded = -1;
			saved = "";
			INPUTMODE = false;
	  } else if (key == BACKSPACE) {
			if (typing.length()>0) typing = typing.substring(0,typing.length()-1);
			else typing = saved;
		} else if (key == CODED) { // Ignore shift/control/tab
			typing = typing;
		} else {
	    typing = typing + key;
	  }
	}

}
class Player
{

  private final float ratio = 35;
  final private float tokenRadius = 1.5f*this.ratio;

  private float x,y;

  private String name;
  private int col;
  private int team;
  private int number;

  private boolean hasBall;

   // name, team, number
  Player(String na, int t, int n, float xx, float yy) {

    if(t == 1)
      this.col = color(0,0,255);
    else
      this.col = color(255,0,0);

    this.name = na;
    this.team = t;
    this.number = n;

    this.x = xx;
    this.y = yy;
  }


  public void drawPlayer() {
    fill(255);
    stroke(this.col);
    circle(this.x, this.y, tokenRadius);
    fill(this.col);
    textAlign(CENTER);
    textSize(30);
    text(this.name, this.x, this.y + tokenRadius);
    textSize(40);
    text(this.number, this.x, this.y+15);
  }

  public void movePlayer(float x, float y) {
    this.setX(x);
    this.setY(y);
  }

  public boolean hasBall(Ball ball) {
    return this.hasBall;
  }

  public void getsBall(Ball ball) {
    this.hasBall = true;
  }

  public void losesBall(Ball ball) {
    this.hasBall = false;
  }


   public boolean overPlayer(float x, float y) {
    if ( (x > this.x - (this.tokenRadius/2)) && (x < this.x + (this.tokenRadius/2)) && (y > this.y - (this.tokenRadius/2))  && (y < this.y + (this.tokenRadius/2)) )   return true;
    return false;
  }



  // GETTERS SETTERS
  public float getX() {
    return this.x;
  }

  public float getY() {
    return this.y;
  }

  public void setX(float xx) {
    this.x = xx;
  }

  public void setY(float yy) {
    this.y = yy;
  }


  public int getColor() {
    return this.col;
  }

  public void setColor(int c) {
    this.col = c;
  }

	public String getName() {
    return this.name;
  }

	public void setName(String n) {
    this.name = n;
  }

  public int getTeam() {
    return this.team;
  }

  public int getNumber() {
    return this.number;
  }

}


// FORMES GEOMETRIQUES
 public void polygon(float x, float y, float radius, int npoints) {
  float angle = TWO_PI / npoints;
  beginShape();
  for (float a = 0; a < TWO_PI; a += angle) {
    float sx = x + cos(a) * radius;
    float sy = y + sin(a) * radius;
    vertex(sx, sy);
  }
  endShape(CLOSE);
}

 public void hexagon(float x, float y, float radius) {
  polygon(x, y, radius, 6);
}

 public void pentagon(float x, float y, float radius) {
  polygon(x, y, radius, 5);
}



// TESTS POSITION SOURIS
 public boolean overMyWindow() {
  if ( (mouseX > 2) && (mouseX <= width -2) && (mouseY > 2)  && (mouseY <= height -2) )   return true;
  return false;
}

 public boolean mouseOverCanvas() {
  if(mouseX < width*0.9f && mouseY < height*0.9f)    return true;
  return false;
}


// CALCULS DE COORDONNEES
 public float[] getRectCenter(float x, float y, float rectWidth, float rectHeight){
  float[] res = new float[2];
  res[0] = (x + x+rectWidth)/2;
  res[1] = (y + y+rectHeight)/2;
  return res;
}


  public void settings() { fullScreen(1); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "mainDev" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
